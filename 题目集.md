# 亲戚

## 题目背景

若某个家族人员过于庞大，要判断两个是否是亲戚，确实还很不容易，现在给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。

## 题目描述

规定：$x$ 和 $y$ 是亲戚，$y$ 和 $z$ 是亲戚，那么 $x$ 和 $z$ 也是亲戚。如果 $x$，$y$ 是亲戚，那么 $x$ 的亲戚都是 $y$ 的亲戚，$y$ 的亲戚也都是 $x$ 的亲戚。

## 输入格式

第一行：三个整数 $n,m,p$，（$n,m,p \le 5000$），分别表示有 $n$ 个人，$m$ 个亲戚关系，询问 $p$ 对亲戚关系。

以下 $m$ 行：每行两个数 $M_i$，$M_j$，$1 \le M_i,~M_j\le n$，表示 $M_i$ 和 $M_j$ 具有亲戚关系。

接下来 $p$ 行：每行两个数 $P_i,P_j$，询问 $P_i$ 和 $P_j$ 是否具有亲戚关系。

## 输出格式

$p$ 行，每行一个 `Yes` 或 `No`。表示第 $i$ 个询问的答案为“具有”或“不具有”亲戚关系。

## 样例 #1

### 样例输入 #1

```
6 5 3
1 2
1 5
3 4
5 2
1 3
1 4
2 3
5 6
```

### 样例输出 #1

```
Yes
Yes
No
```
## Solution 
```c++
const int N = 5001;
int n, m, p;
int f[N];

int find(int x) {
    return f[x] == x ? x : f[x] = find(f[x]);
}

void combine(int u, int v) {
    u = find(u);
    v = find(v);
    if (u != v) {
        f[u] = v;
    }
}

void solve() {
    cin >> n >> m >> p;
    for (int i = 1;i <= n;++i) f[i] = i;
    for (int i = 1;i <= m;++i) {
        int u, v;
        cin >> u >> v;
        combine(u, v);
    }
    for (int i = 1;i <= p;++i) {
        int u, v;
        cin >> u >> v;
        if (find(u) == find(v))
            cout << "Yes" << endl;
        else
            cout << "No" << endl;
    }
}
```
# 村村通

## 题目描述

某市调查城镇交通状况，得到现有城镇道路统计表。表中列出了每条道路直接连通的城镇。市政府 "村村通工程" 的目标是使全市任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要相互之间可达即可）。请你计算出最少还需要建设多少条道路？

## 输入格式

输入包含若干组测试数据，每组测试数据的第一行给出两个用空格隔开的正整数，分别是城镇数目 $n$ 和道路数目 $m$ ；随后的 $m$ 行对应 $m$ 条道路，每行给出一对用空格隔开的正整数，分别是该条道路直接相连的两个城镇的编号。简单起见，城镇从 $1$ 到 $n$ 编号。

注意：两个城市间可以有多条道路相通。

**在输入数据的最后，为一行一个整数 $0$，代表测试数据的结尾。**

## 输出格式

对于每组数据，对应一行一个整数。表示最少还需要建设的道路数目。

## 样例 #1

### 样例输入 #1

```
4 2
1 3
4 3
3 3
1 2
1 3
2 3
5 2
1 2
3 5
999 0
0
```

### 样例输出 #1

```
1
0
2
998
```

## 提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \le n < 1000$ 。
## Solution
```c++
const int N = 1001;
int need;
int f[N];

int find(int x) {
    return f[x] == x ? x : f[x] = find(f[x]);
}

void combine(int u, int v) {
    u = find(u);
    v = find(v);
    if (u != v) {
        f[u] = v;
        need--;
    }
}

void solve() {
    while (true) {
        int n, m;
        cin >> n;
        if (!n) break;
        cin >> m;
        need = n - 1;
        for (int i = 1;i <= n;++i) f[i] = i;
        for (int i = 1;i <= m;++i) {
            int u, v;
            cin >> u >> v;
            combine(u, v);
        }
        cout << need << endl;
    }
}
```
# [USACO16DEC] Cities and States S

## 题目描述

Farmer John 有若干头奶牛。为了训练奶牛们的智力，Farmer John 在谷仓的墙上放了一张美国地图。地图上表明了每个城市及其所在州的代码（前两位大写字母）。

由于奶牛在谷仓里花了很多时间看这张地图，他们开始注意到一些奇怪的关系。例如，FLINT 的前两个字母就是 MIAMI 所在的 `FL` 州，MIAMI 的前两个字母则是 FLINT 所在的 `MI` 州。  
确切地说，对于两个城市，它们的前两个字母互为对方所在州的名称。

我们称两个城市是一个一对「特殊」的城市，如果他们具有上面的特性，并且来自不同的州。对于总共 $N$ 座城市，奶牛想知道有多少对「特殊」的城市存在。请帮助他们解决这个有趣的地理难题！

## 输入格式

输入共 $N + 1$ 行。

第一行一个正整数 $N$，表示地图上的城市的个数。  
接下来 $N$ 行，每行两个字符串，分别表示一个城市的名称（$2 \sim 10$ 个大写字母）和所在州的代码（$2$ 个大写字母）。同一个州内不会有两个同名的城市。

## 输出格式

输出共一行一个整数，代表特殊的城市对数。

## 样例 #1

### 样例输入 #1

```
6
MIAMI FL
DALLAS TX
FLINT MI
CLEMSON SC
BOSTON MA
ORLANDO FL
```

### 样例输出 #1

```
1
```

## 提示

### 数据规模与约定

对于 $100\%$ 的数据，$1 \leq N \leq 2 \times 10 ^ 5$，城市名称长度不超过 $10$。
```c++
const ll N = 31*26+26+1;
ll mp[N][N];
ll n;

ll gethash(const string& s) {
    return (s[0] - 'A') * 31 + s[1] - 'A';
}

void solve() {
    cin >> n;
    ll ans = 0;
    for (ll i = 1;i <= n;++i) {
        string a, b;
        cin >> a >> b;
        if (gethash(a) != gethash(b)) {
            mp[gethash(a)][gethash(b)]++;
            ans += mp[gethash(b)][gethash(a)];
        }
    }
    cout << ans << endl;
}
```
# 【模板】行列式求值

## 题目描述

给定一个 $n$ 阶行列式 $A$，求 $|A|$。结果对 $p$ 取模。

## 输入格式

第一行两个正整数 $n$ 和 $p$。

接下来共 $n$ 行，第 $i+1$ 行 $n$ 个正整数，其中第 $j$ 个表示 $A_{i,j}$。

## 输出格式

输出 $|A|$ 在模 $p$ 意义下的最小自然数值。

## 样例 #1

### 样例输入 #1

```
2 998244353
1 4
1 5
```

### 样例输出 #1

```
1
```

## 提示

对于 $100\%$ 的数据，$1\le n\le 600$，$1\le a_{i,j}< 10^9+7$，$1\le p\le 10^9+7$。

存在部分测试点满足 $p$ 为素数、$\mu{(p)}\ne 0$ ，可以用于测试其他算法。

## 算法
```
使用辗转消元法来解决精度问题和无乘法逆元问题
```

## Solution
```c++
const int N = 601;
int n, p;
int a[N][N];

int read(){
    int x = 0, w = 1;char ch = getchar();
    while ((ch < '0' || ch>'9') && ch != '-')ch = getchar();
    if (ch == '-')w = -1, ch = getchar();
    while (ch >= '0' && ch <= '9')x = (x << 1) + (x << 3) + ch - 48, ch = getchar();
    return x * w;
}

void solve() {
    n = read();
    p = read();
    for (int i = 1;i <= n;++i)
        for (int j = 1;j <= n;++j)
            a[i][j]= read();
    int sign = 1;
    for (int i = 1;i <= n;++i) {
        for (int j = i + 1;j <= n;++j) {
            while (a[i][i]) {
                int div = a[j][i] / a[i][i];
                for (int k = i;k <= n;++k)
                    a[j][k] = (a[j][k] - 1ll * div * a[i][k] % p + p) % p;
                swap(a[i], a[j]);
                sign = -sign;
            }
            swap(a[i], a[j]);
            sign = -sign;
        }
    }
    int ans = sign;
    for (int i = 1;i <= n;++i)
        ans = 1ll * ans * a[i][i] % p;
    cout << (ans%p+p)%p << endl;
}
```

# [USACO08DEC] Secret Message G

## 题目描述

Bessie is leading the cows in an attempt to escape! To do this, the cows are sending secret binary messages to each other.

Ever the clever counterspy, Farmer John has intercepted the first $b_i$ ($1 \le b_i \le 10,000$) bits of each of $M$ ($1 \le M \le 50,000$) of these secret binary messages.

He has compiled a list of $N$ ($1 \le N \le 50,000$) partial codewords that he thinks the cows are using. Sadly, he only knows the first $c_j$ ($1 \le c_j \le 10,000$) bits of codeword $j$.

For each codeword $j$, he wants to know how many of the intercepted messages match that codeword (i.e., for codeword $j$, how many times does a message and the codeword have the same initial bits). Your job is to compute this number.

The total number of bits in the input (i.e., the sum of the $b_i$ and the $c_j$) will not exceed  $500,000$.

贝茜正在领导奶牛们逃跑．为了联络，奶牛们互相发送秘密信息．

信息是二进制的，共有 $M$（$1 \le M \le 50000$）条，反间谍能力很强的约翰已经部分拦截了这些信息，知道了第  $i$ 条二进制信息的前 $b_i$（$1 \le b_i \le 10000$）位，他同时知道，奶牛使用 $N$（$1 \le N \le 50000$）条暗号．但是，他仅仅知道第 $j$ 条暗号的前 $c_j$（$1 \le c_j \le 10000$）位。

对于每条暗号 $j$，他想知道有多少截得的信息能够和它匹配。也就是说，有多少信息和这条暗号有着相同的前缀。当然，这个前缀长度必须等于暗号和那条信息长度的较小者。

在输入文件中，位的总数（即 $\sum b_i + \sum c_i$）不会超过 $500000$。

## 输入格式

Line $1$: Two integers: $M$ and $N$.

Lines $2 \ldots M+1$: Line $i+1$ describes intercepted code $i$ with an integer $b_i$ followed by $b_i$ space-separated `0`'s and `1`'s.

Lines $M+2 \ldots M+N+1$: Line $M+j+1$ describes codeword $j$ with an integer $c_j$ followed by $c_j$ space-separated `0`'s and `1`'s.

## 输出格式

Lines $1 \ldots N$: Line $j$: The number of messages that the $j$-th codeword could match.

## 样例 #1

### 样例输入 #1

```
4 5 
3 0 1 0 
1 1 
3 1 0 0 
3 1 1 0 
1 0 
1 1 
2 0 1 
5 0 1 0 0 1 
2 1 1
```

### 样例输出 #1

```
1 
3 
1 
1 
2
```

## 提示

Four messages; five codewords. 

The intercepted messages start with 010, 1, 100, and 110.

The possible codewords start with 0, 1, 01, 01001, and 11.


0 matches only 010: 1 match

1 matches 1, 100, and 110: 3 matches

01 matches only 010: 1 match

01001 matches 010: 1 match

11 matches 1 and 110: 2 matches

## Solution
```c++
const int N = 1e7 + 1;
int n, m;

using trienode = int[2];

vector<trienode> trie(N);
int nums[N];
int after[N];
int cnt;

void solve() {
    cin >> n >> m;
    for (int i = 1;i <= n;++i) {
        int b;cin >> b;
        int p = 0, val;

        for (int j = 1;j <= b;++j) {
            cin >> val;
            if (!trie[p][val]) trie[p][val] = ++cnt;
            p = trie[p][val];
            after[p]++;
        }
        nums[p]++;
    }

    for (int i = 1;i <= m;++i) {
        int ans = 0, p = 0,val,flag = 1;
        int b;cin >> b;
        for (int i = 1;i <= b;++i) {
            cin >> val;
            if (flag && trie[p][val]) {
                ans += nums[trie[p][val]];
                p = trie[p][val];
            }
            else flag = 0;
        }
        if (flag == 1) {
            ans += after[trie[p][0]];
            ans += after[trie[p][1]];
        }
        cout << ans << endl;
    }
}
```
# 小鸟的设备

## 题目背景

小鸟有 $n$ 个可同时使用的设备。

## 题目描述

第 $i$ 个设备每秒消耗 $a_i$ 个单位能量。能量的使用是连续的，也就是说能量不是某时刻突然消耗的，而是匀速消耗。也就是说，对于任意实数，在 $k$ 秒内消耗的能量均为 $k\times a_i$ 单位。在开始的时候第 $i$ 个设备里存储着 $b_i$ 个单位能量。

同时小鸟又有一个可以给任意一个设备充电的充电宝，每秒可以给接通的设备充能 $p$ 个单位，充能也是连续的，不再赘述。你可以在任意时间给任意一个设备充能，从一个设备切换到另一个设备的时间忽略不计。

小鸟想把这些设备一起使用，直到其中有设备能量降为  $0$。所以小鸟想知道，在充电器的作用下，她最多能将这些设备一起使用多久。

## 输入格式

第一行给出两个整数 $n,p$。

接下来 $n$ 行，每行表示一个设备，给出两个整数，分别是这个设备的 $a_i$ 和 $b_i$。

## 输出格式

如果小鸟可以无限使用这些设备，输出 $-1$。

否则输出小鸟在其中一个设备能量降为 $0$ 之前最多能使用多久。

设你的答案为 $a$，标准答案为 $b$，只有当 $a,b$ 满足 
$\dfrac{|a-b|}{\max(1,b)} \leq 10^{-4}$ 的时候，你能得到本测试点的满分。

## 样例 #1

### 样例输入 #1

```
2 1
2 2
2 1000
```

### 样例输出 #1

```
2.0000000000
```

## 样例 #2

### 样例输入 #2

```
1 100
1 1
```

### 样例输出 #2

```
-1
```

## 样例 #3

### 样例输入 #3

```
3 5
4 3
5 2
6 1
```

### 样例输出 #3

```
0.5000000000
```

## 提示

对于 $100\%$ 的数据，$1\leq n\leq 100000$，$1\leq p\leq 100000$，$1\leq a_i,b_i\leq100000$。

## Solution
```c++
const int N = 1e5 + 1;
int a[N], b[N];
int n, p;

bool chck(ld x) {
    ld mx = p * x;
    for (int i = 1;i <= n;++i) {
        if (x * a[i] > b[i])
            mx -= (x * a[i] - b[i]);
        if (mx < 0) return false;
    }
    return true;
}

void solve() {
    cin >> n >> p;
    int sum = 0;
    for (int i = 1;i <= n;++i) {
        cin >> a[i] >> b[i];
        sum+=a[i];
    }

    if (sum <= p) {
        cout << -1 << endl;
        return;
    }

    ld l = 0, r = 1e14;
    while (r - l >= 1e-8) {
        ld m = (l + r) / 2;
        if (chck(m)) {
            l = m;
        }
        else r = m;
    }

    cout << l << endl;
}
```

# [NOIP2001 提高组] 一元三次方程求解

## 题目描述

有形如：$a x^3 + b x^2 + c x + d = 0$  这样的一个一元三次方程。给出该方程中各项的系数（$a,b,c,d$ 均为实数），并约定该方程存在三个不同实根（根的范围在 $-100$ 至 $100$ 之间），且根与根之差的绝对值 $\ge 1$。要求由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后 $2$ 位。

提示：记方程 $f(x) = 0$，若存在 $2$ 个数 $x_1$ 和 $x_2$，且 $x_1 < x_2$，$f(x_1) \times f(x_2) < 0$，则在 $(x_1, x_2)$ 之间一定有一个根。

## 输入格式

一行，$4$ 个实数 $a, b, c, d$。

## 输出格式

一行，$3$ 个实根，从小到大输出，并精确到小数点后 $2$ 位。

## 样例 #1

### 样例输入 #1

```
1 -5 -4 20
```

### 样例输出 #1

```
-2.00 2.00 5.00
```
## Solution
```c++
ld a[4];
ld f(ld x) {
    return a[0] * x * x * x + a[1] * x * x + a[2] * x + a[3];
}

void solve() {
    cin >> a[0] >> a[1] >> a[2] >> a[3];
    cout << fixed << setprecision(2);
    for (int i = -100;i <= 99;++i) {
        ld l = i, r = i + 1 - 0.001;
        while (r - l >= 1e-4) {
            ld m = (l + r) / 2;
            if (f(l) * f(m) <= 1e-10)
                r = m;
            else if (f(m) * f(r) <= 1e-10)
                l = m;
            else break;
        }
        if(r-l<1e-3)
            cout << l << ' ';
    }
}
```


